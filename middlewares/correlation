# middlewares/correlation.py
from __future__ import annotations
import uuid
from typing import Any, Awaitable, Callable, Dict

from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, Message, CallbackQuery

from utils.logging import set_request_id, get_logger


class CorrelationMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        request_id = str(uuid.uuid4())
        set_request_id(request_id)

        user_id: str | None = None
        if isinstance(event, Message) and event.from_user:
            user_id = str(event.from_user.id)
        elif isinstance(event, CallbackQuery) and event.from_user:
            user_id = str(event.from_user.id)

        log = get_logger(__name__)
        log.info(
            "update received",
            extra={"request_id": request_id, "user_id": user_id, "update_type": type(event).__name__},
        )
        try:
            return await handler(event, data)
        finally:
            # очистим контекст, чтобы request_id не «протекал» в следующий апдейт
            set_request_id(None)

    
    def _extract_user_id(self, event: Update, data: Dict[str, Any]) -> Optional[str]:
        """Извлекает user_id из update или data."""
        # Пробуем получить из data (если другие middleware уже извлекли)
        if "event_from_user" in data:
            user: User = data["event_from_user"]
            return str(user.id) if user else None
        
        # Пробуем извлечь из разных типов update
        if event.message and event.message.from_user:
            return str(event.message.from_user.id)
        elif event.callback_query and event.callback_query.from_user:
            return str(event.callback_query.from_user.id)
        elif event.inline_query and event.inline_query.from_user:
            return str(event.inline_query.from_user.id)
        elif event.edited_message and event.edited_message.from_user:
            return str(event.edited_message.from_user.id)
        elif event.my_chat_member and event.my_chat_member.from_user:
            return str(event.my_chat_member.from_user.id)
        
        return None
    
    def _get_update_type(self, event: Update) -> str:
        """Определяет тип update."""
        if event.message:
            return "message"
        elif event.callback_query:
            return "callback_query"
        elif event.inline_query:
            return "inline_query"
        elif event.edited_message:
            return "edited_message"
        elif event.my_chat_member:
            return "my_chat_member"
        elif event.poll:
            return "poll"
        elif event.poll_answer:
            return "poll_answer"
        else:
            return "unknown"